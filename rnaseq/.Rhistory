# Heatmap
library(pheatmap)
# enrichR provides functional gene set enrichment analysis
library(enrichR)
# Read the count matrix
counts <- read.csv("data/counts.csv")
# Read metadata
meta <- read.csv("data/meta.csv", stringsAsFactors = F)
# Remove rows with duplicated row names
if (length(which(duplicated.default(counts[, 1]))) > 0) {
counts <- counts[-which(duplicated.default(counts[, 1]) == T),]
}
rownames(counts) <- counts[, 1]
counts <- counts[,-1]
# You can filter the genes with low counts, it is called most minimal filtering rule: removing rows of the dataset that have no counts, or only a count of 10 across all samples. The value can be adjusted based on your dataset condition.
keep <- rowSums(counts) >= 10
# For some datasets, it may make sense to perform additional filtering. For example, one can specify that at least 5 samples have a count of 10 or higher. One recommendation for the number of samples would be set to the smallest group size.
keep <- rowSums(counts >= 10) >= 5
counts <- counts[keep, ]
# Print the first 10 rows of the count matrix
counts[1:10, ]
# Print the metadata
meta
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~ treatment
)
vsd <- vst(dds, blind = FALSE)
pcaData <- plotPCA(vsd, intgroup=c("treatment"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=treatment)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed() +
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time, label=name)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic() + geom_text_repel() + labs(title = "geom_text_repel()")
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time, label=name)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic() + geom_text_repel() + labs(title = "geom_text_repel()")
knitr::opts_chunk$set(echo = TRUE)
bioc_packages <- c("DESeq2", "EnhancedVolcano")
cran_packages <- c("enrichR",
"ggpubr",
"pheatmap",
"ggplot2",
"VennDiagram",
"stringr",
"here")
bioc_np <-
bioc_packages[!(bioc_packages %in% installed.packages()[, "Package"])]
cran_np <-
cran_packages[!(cran_packages %in% installed.packages()[, "Package"])]
if (!require("BiocManager"))
install.packages("BiocManager")
if (length(cran_np)) {
install.packages(cran_np)
}
if (length(bioc_np)) {
BiocManager::install(bioc_np)
}
# 'here' pacakge automatically sets working directory for us
library(here)
# DESeq2 provides methods to test for differential gene expression (DGE) analysis
library(DESeq2)
# ‘ggplot2’ and its extension for publication ready plots
library(ggplot2)
library(ggpubr)
# Volcano plot
library(EnhancedVolcano)
# Heatmap
library(pheatmap)
# enrichR provides functional gene set enrichment analysis
library(enrichR)
# Read the count matrix
counts <- read.csv("data/counts.csv")
# Read metadata
meta <- read.csv("data/meta.csv", stringsAsFactors = F)
# Remove rows with duplicated row names
if (length(which(duplicated.default(counts[, 1]))) > 0) {
counts <- counts[-which(duplicated.default(counts[, 1]) == T),]
}
rownames(counts) <- counts[, 1]
counts <- counts[,-1]
# You can filter the genes with low counts, it is called most minimal filtering rule: removing rows of the dataset that have no counts, or only a count of 10 across all samples. The value can be adjusted based on your dataset condition.
keep <- rowSums(counts) >= 10
# For some datasets, it may make sense to perform additional filtering. For example, one can specify that at least 5 samples have a count of 10 or higher. One recommendation for the number of samples would be set to the smallest group size.
keep <- rowSums(counts >= 10) >= 5
counts <- counts[keep, ]
# Print the first 10 rows of the count matrix
counts[1:10, ]
# Print the metadata
meta
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~ treatment
)
vsd <- vst(dds, blind = FALSE)
pcaData <- plotPCA(vsd, intgroup=c("treatment"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=treatment)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed() +
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time, label=name)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic() + geom_text_repel() + labs(title = "geom_text_repel()")
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time, label=name)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
s1 <-
subset(meta,
meta$treatment == "treatment" & meta$time == "day3")
s2 <- subset(meta, meta$treatment == "treatment" & meta$time == "day7")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(countData = counts[, as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <-
DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(object = dds1,
contrast = c("group", "Group1", "Group2"))
res <- res[order(res$padj), ]
resLFC <- res
summary(resLFC, alpha = 0.05)
DT::datatable(
as.data.frame(resLFC),
extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
)
)
#write.csv(resLFC,"comparison1.csv")
knitr::opts_chunk$set(echo = TRUE)
bioc_packages <- c("DESeq2", "EnhancedVolcano")
cran_packages <- c("enrichR",
"ggpubr",
"pheatmap",
"ggplot2",
"VennDiagram",
"stringr",
"here")
bioc_np <-
bioc_packages[!(bioc_packages %in% installed.packages()[, "Package"])]
cran_np <-
cran_packages[!(cran_packages %in% installed.packages()[, "Package"])]
if (!require("BiocManager"))
install.packages("BiocManager")
if (length(cran_np)) {
install.packages(cran_np)
}
if (length(bioc_np)) {
BiocManager::install(bioc_np)
}
# 'here' pacakge automatically sets working directory for us
library(here)
# DESeq2 provides methods to test for differential gene expression (DGE) analysis
library(DESeq2)
# ‘ggplot2’ and its extension for publication ready plots
library(ggplot2)
library(ggpubr)
# Volcano plot
library(EnhancedVolcano)
# Heatmap
library(pheatmap)
# enrichR provides functional gene set enrichment analysis
library(enrichR)
# Read the count matrix
counts <- read.csv("data/counts.csv")
# Read metadata
meta <- read.csv("data/meta.csv", stringsAsFactors = F)
# Remove rows with duplicated row names
if (length(which(duplicated.default(counts[, 1]))) > 0) {
counts <- counts[-which(duplicated.default(counts[, 1]) == T),]
}
rownames(counts) <- counts[, 1]
counts <- counts[,-1]
# You can filter the genes with low counts, it is called most minimal filtering rule: removing rows of the dataset that have no counts, or only a count of 10 across all samples. The value can be adjusted based on your dataset condition.
keep <- rowSums(counts) >= 10
# For some datasets, it may make sense to perform additional filtering. For example, one can specify that at least 5 samples have a count of 10 or higher. One recommendation for the number of samples would be set to the smallest group size.
keep <- rowSums(counts >= 10) >= 5
counts <- counts[keep, ]
# Print the first 10 rows of the count matrix
counts[1:10, ]
# Print the metadata
meta
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~ treatment
)
vsd <- vst(dds, blind = FALSE)
pcaData <- plotPCA(vsd, intgroup=c("treatment"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=treatment)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed() +
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time, label=name)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
s1 <-
subset(meta,
meta$treatment == "treatment" & meta$time == "day3")
s2 <- subset(meta, meta$treatment == "treatment" & meta$time == "day7")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(countData = counts[, as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <-
DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(object = dds1,
contrast = c("group", "Group1", "Group2"))
result <- res[order(res$padj), ]
summary(result, alpha = 0.05)
DT::datatable(
as.data.frame(result),
extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
)
)
#write.csv(resLFC,"comparison1.csv")
ggmaplot(result,
fdr = 0.05, fc = 1.5, size = 0.5,
palette = c("#B31B21", "#1465AC", "darkgray"),
genenames = as.vector(rownames(result)),
legend = "top", top = 10,
font.label = c("bold", 11),
font.legend = "bold",
font.main = "bold",
ggtheme = ggplot2::theme_minimal())
top_up <- rownames(result[which(result$log2FoldChange > 0),])[1:5]
top_down <- rownames(result[which(result$log2FoldChange < 0),])[1:5]
EnhancedVolcano(result,
lab = rownames(result),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
xlim = c(-8, 8),
pCutoff = 0.05,
FCcutoff = 1.5,
)
top_up <- rownames(result[which(result$log2FoldChange > 0),])[1:5]
top_down <- rownames(result[which(result$log2FoldChange < 0),])[1:5]
EnhancedVolcano(result,
lab = rownames(result),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
pCutoff = 0.05,
FCcutoff = 1.5,
)
s1 <-
subset(meta,
meta$treatment == "treatment" & meta$time == "day7")
s2 <- subset(meta, meta$treatment == "control" & meta$time == "day7")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(countData = counts[, as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <-
DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(object = dds1,
contrast = c("group", "Group1", "Group2"))
result <- res[order(res$padj), ]
summary(result, alpha = 0.05)
DT::datatable(
as.data.frame(result),
extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
)
)
#write.csv(result,"comparison1.csv")
ggmaplot(result,
fdr = 0.05, fc = 1.5, size = 0.5,
palette = c("#B31B21", "#1465AC", "darkgray"),
genenames = as.vector(rownames(result)),
legend = "top", top = 10,
font.label = c("bold", 11),
font.legend = "bold",
font.main = "bold",
ggtheme = ggplot2::theme_minimal())
top_up <- rownames(result[which(result$log2FoldChange > 0),])[1:5]
top_down <- rownames(result[which(result$log2FoldChange < 0),])[1:5]
EnhancedVolcano(result,
lab = rownames(result),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
pCutoff = 0.05,
FCcutoff = 1.5,
)
top_up <- rownames(result[which(result$log2FoldChange > 0),])[1:5]
top_down <- rownames(result[which(result$log2FoldChange < 0),])[1:5]
EnhancedVolcano(result,
lab = rownames(result),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
pCutoff = 0.05,
FCcutoff = 1.5,
)
## Select Gene ontology and KEGG pathway databases
dbs <- c("GO_Molecular_Function_2018", "GO_Cellular_Component_2018", "GO_Biological_Process_2018","KEGG_2019_Human")
# This select genes with adj.p.value < 0.05 and log2foldchange > 1.5 for enrichment analysis
enriched_combined <- enrichr(rownames(result[which(result$padj < 0.05 & abs(result$log2FoldChange) > 1.5),]),dbs)
# output top 20 enriched terms
DT::datatable(head(enriched_combined$GO_Biological_Process_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
# Hide all warnings and messages, show code
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(echo = TRUE)
bioc_packages <- c("DESeq2", "EnhancedVolcano")
cran_packages <- c("enrichR",
"ggpubr",
"pheatmap",
"ggplot2",
"VennDiagram",
"stringr",
"here")
bioc_np <-
bioc_packages[!(bioc_packages %in% installed.packages()[, "Package"])]
cran_np <-
cran_packages[!(cran_packages %in% installed.packages()[, "Package"])]
if (!require("BiocManager"))
install.packages("BiocManager")
if (length(cran_np)) {
install.packages(cran_np)
}
if (length(bioc_np)) {
BiocManager::install(bioc_np)
}
# 'here' pacakge automatically sets working directory for us
library(here)
# DESeq2 provides methods to test for differential gene expression (DGE) analysis
library(DESeq2)
# ‘ggplot2’ and its extension for publication ready plots
library(ggplot2)
library(ggpubr)
# Volcano plot
library(EnhancedVolcano)
# Heatmap
library(pheatmap)
# enrichR provides functional gene set enrichment analysis
library(enrichR)
summary(result, alpha = 0.05)
DT::datatable(
as.data.frame(result[result$padj<0.05,]),
extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
)
)
result$padj
DT::datatable(
result[result$padj<0.05,],
extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
)
)
s1 <-
subset(meta,
meta$treatment == "treatment" & meta$time == "day7")
s2 <- subset(meta, meta$treatment == "control" & meta$time == "day7")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(countData = counts[, as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <-
DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(object = dds1,
contrast = c("group", "Group1", "Group2"))
result <- as.data.frame(res[order(res$padj), ])
summary(result, alpha = 0.05)
#write.csv(result,"comparison1.csv")
s1 <-
subset(meta,
meta$treatment == "treatment" & meta$time == "day7")
s2 <- subset(meta, meta$treatment == "control" & meta$time == "day7")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(countData = counts[, as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <-
DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(object = dds1,
contrast = c("group", "Group1", "Group2"))
result <- as.data.frame(res[order(res$padj), ])
summary(res, alpha = 0.05)
#write.csv(result,"comparison1.csv")
DT::datatable(
result[result$padj<0.05,],
extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
)
)
