counts <- counts[keep, ]
# For example use and speed up the process, we only select top 3000 genes for downstream analysis
counts <- counts[1:3000,]
# Overview of the dataset
counts[1:10, 1:10]
meta[1:10,]
knitr::opts_chunk$set(echo = TRUE)
bioc_packages <- c(
"DESeq2","EnhancedVolcano"
)
cran_packages <- c(
"enrichR","ggpubr","pheatmap","ggplot2","VennDiagram"
)
bioc_np <- bioc_packages[!(bioc_packages %in% installed.packages()[,"Package"])]
cran_np <- cran_packages[!(cran_packages %in% installed.packages()[,"Package"])]
if (!require("BiocManager")) install.packages("BiocManager")
if(length(cran_np)) {
install.packages(cran_np)
}
if(length(bioc_np)) {
install.packages(BiocManager::install(bioc_np))
}
#library(RColorBrewer)
#library(Polychrome)
library(ggplot2)
#library(tidyverse)
#library(dabestr)
#library(enrichR)
#library(ggpubr)
#library(Hmisc)
library(ggpubr)
library(EnhancedVolcano)
library(VennDiagram)
#library(ggrepel)
#library(ggfortify)
library(pheatmap)
library(DESeq2)
knitr::opts_knit$set(root.dir = "C:/Users/flyku/Documents/GitHub/RNA-seq-pipeline/rnaseq")
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~sample
)
vsd <- vst(dds, blind = FALSE)
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~skin
)
vsd <- vst(dds, blind = FALSE)
## Change to human or mouse
dbs <- c("GO_Molecular_Function_2018", "GO_Cellular_Component_2018", "GO_Biological_Process_2018","KEGG_2019_Mouse")
counts <- read.csv("counts.csv",stringsAsFactors = F,check.names = F)
meta <- read.csv("meta.csv",stringsAsFactors = F)
# Remove duplicated row names
if(length(which(duplicated.default(counts[,1]))) > 0 ){
counts <- counts[-which(duplicated.default(counts[,1])==T),]
}
rownames(counts) <- counts[,1]
counts <- counts[,-1]
# You can filter the genes with low counts, it is called most minimal filtering rule: removing rows of the dataset that have no counts, or only a count of 10 across all samples. The value can be adjusted based on your dataset condition.
keep <- rowSums(counts) >= 10
# For some datasets, it may make sense to perform additional filtering. For example, one can specify that at least 5 samples have a count of 10 or higher. One recommendation for the number of samples would be set to the smallest group size.
keep <- rowSums(counts >= 10) >= 5
counts <- counts[keep, ]
# For example use and speed up the process, we only select top 3000 genes for downstream analysis, remember to delete this line
counts <- counts[1:3000,]
# Overview of the dataset
counts[1:10, 1:10]
meta[1:10,]
# choose whahtever column as design
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~ skin
)
vsd <- vst(dds, blind = FALSE)
pcaData <- plotPCA(vsd, intgroup=c("injury"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=injury)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed() +
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("skin"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=skin)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("skin","time","injury","injury_size"), returnData=TRUE)
vsd
counts <- counts[sample(1:nrow(counts),3000),]
## Change to human or mouse
dbs <- c("GO_Molecular_Function_2018", "GO_Cellular_Component_2018", "GO_Biological_Process_2018","KEGG_2019_Mouse")
counts <- read.csv("counts.csv",stringsAsFactors = F,check.names = F)
meta <- read.csv("meta.csv",stringsAsFactors = F)
# Remove duplicated row names
if(length(which(duplicated.default(counts[,1]))) > 0 ){
counts <- counts[-which(duplicated.default(counts[,1])==T),]
}
rownames(counts) <- counts[,1]
counts <- counts[,-1]
# You can filter the genes with low counts, it is called most minimal filtering rule: removing rows of the dataset that have no counts, or only a count of 10 across all samples. The value can be adjusted based on your dataset condition.
keep <- rowSums(counts) >= 10
# For some datasets, it may make sense to perform additional filtering. For example, one can specify that at least 5 samples have a count of 10 or higher. One recommendation for the number of samples would be set to the smallest group size.
keep <- rowSums(counts >= 10) >= 5
counts <- counts[keep, ]
# For example use and speed up the process, we only select top 3000 genes for downstream analysis, remember to delete this line
counts <- counts[sample(1:nrow(counts),3000),]
# Overview of the dataset
counts[1:10, 1:10]
meta[1:10,]
## Change to human or mouse
dbs <- c("GO_Molecular_Function_2018", "GO_Cellular_Component_2018", "GO_Biological_Process_2018","KEGG_2019_Mouse")
counts <- read.csv("counts.csv",stringsAsFactors = F,check.names = F)
meta <- read.csv("meta.csv",stringsAsFactors = F)
# Remove duplicated row names
if(length(which(duplicated.default(counts[,1]))) > 0 ){
counts <- counts[-which(duplicated.default(counts[,1])==T),]
}
rownames(counts) <- counts[,1]
counts <- counts[,-1]
# You can filter the genes with low counts, it is called most minimal filtering rule: removing rows of the dataset that have no counts, or only a count of 10 across all samples. The value can be adjusted based on your dataset condition.
keep <- rowSums(counts) >= 10
# For some datasets, it may make sense to perform additional filtering. For example, one can specify that at least 5 samples have a count of 10 or higher. One recommendation for the number of samples would be set to the smallest group size.
keep <- rowSums(counts >= 10) >= 5
counts <- counts[keep, ]
# For example use and speed up the process, we only select top 4000 genes for downstream analysis, remember to delete this line
counts <- counts[sample(1:nrow(counts),4000),]
# Overview of the dataset
counts[1:10, 1:10]
meta[1:10,]
# choose whahtever column as design
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~ skin
)
vsd <- vst(dds, blind = FALSE)
pcaData <- plotPCA(vsd, intgroup=c("injury"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=injury)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed() +
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("skin"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=skin)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("skin","time","injury","injury_size"), returnData=TRUE)
vsd
# choose whahtever column as design
dds <- DESeq2::DESeqDataSetFromMatrix(
countData = counts,
colData = meta,
design = ~ injury
)
vsd <- vst(dds, blind = FALSE)
pcaData <- plotPCA(vsd, intgroup=c("injury"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=injury)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed() +
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("time"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("skin"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=skin)) +
geom_point(size=3) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic()
pcaData <- plotPCA(vsd, intgroup=c("skin","time","injury","injury_size"), returnData=TRUE)
colData(dds)
pcaData <- plotPCA(vsd, intgroup=c("skin","time","injury"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=time, shape=skin, size=factor(injury))) +
geom_point() +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
coord_fixed()+
theme_classic() +
labs( size="Injury", shape="Skin", color="Time")
colData(dds)
heat.counts <- assay(vsd)
num <- 30
topID <- order(rowMeans(heat.counts), decreasing = TRUE)
heat.mat <- heat.counts[topID, ]
heat.mat <- heat.mat - rowMeans(heat.mat)
heat.mat <- heat.mat[1:num, ,drop = FALSE]
rownames(heat.mat)
colnames(heat.mat) <- meta$sample
my_sample_col <- meta
rownames(my_sample_col) <- meta$sample
my_sample_col <- meta[,c(4,5,3)]
rownames(my_sample_col) <- meta$sample
pheatmap(
mat = heat.mat,
cluster_rows = T,
cluster_cols = T,
main = "Heatmap of the 30 most expressed IDs",
annotation_col = my_sample_col,
show_rownames=T,
show_colnames = T
)
heat.counts <- assay(vsd)
num <- 50
topID <- order(rowMeans(heat.counts), decreasing = TRUE)
heat.mat <- heat.counts[topID, ]
heat.mat <- heat.mat - rowMeans(heat.mat)
heat.mat <- heat.mat[1:num, ,drop = FALSE]
rownames(heat.mat)
colnames(heat.mat) <- meta$sample
my_sample_col <- meta
rownames(my_sample_col) <- meta$sample
my_sample_col <- meta[,c(4,5,3)]
rownames(my_sample_col) <- meta$sample
pheatmap(
mat = heat.mat,
cluster_rows = T,
cluster_cols = T,
main = "Heatmap of the 50 most expressed IDs",
annotation_col = my_sample_col,
show_rownames=T,
show_colnames = T
)
s1 <- subset(meta, meta$injury == "lam" & meta$time == "7dpw" & meta$skin == "wound")
s2 <- subset(meta, meta$injury == "SCI" & meta$skin == "wound")
cells.1 = rownames(s1)
cells.2 = rownames(s2)
group.info <- data.frame(row.names = c(cells.1, cells.2))
group.info[cells.1, "group"] <- "Group1"
group.info[cells.2, "group"] <- "Group2"
group.info[, "group"] <- factor(x = group.info[, "group"])
group.info$wellKey <- rownames(x = group.info)
dds1 <- DESeq2::DESeqDataSetFromMatrix(
countData = counts[,as.numeric(c(cells.1, cells.2))],
colData = group.info,
design = ~ group
)
dds1 <- DESeq2::estimateSizeFactors(object = dds1)
dds1 <- DESeq2::estimateDispersions(object = dds1, fitType = "local")
dds1 <- DESeq2::nbinomWaldTest(object = dds1)
res <- DESeq2::results(
object = dds1,
contrast = c("group", "Group1", "Group2")
)
res <- res[order(res$padj),]
resLFC <- res
summary(resLFC, alpha=0.05)
DT::datatable(as.data.frame(resLFC), extensions = 'FixedColumns',
options = list(
pageLength = 20,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
))
#write.csv(result,"cDC_vs_Mac.csv")
ggmaplot(resLFC,
fdr = 0.05, fc = 1.5, size = 0.5,
palette = c("#B31B21", "#1465AC", "darkgray"),
genenames = as.vector(rownames(resLFC)),
legend = "top", top = 10,
font.label = c("bold", 11),
font.legend = "bold",
font.main = "bold",
ggtheme = ggplot2::theme_minimal())
top_up <- rownames(resLFC[which(resLFC$log2FoldChange > 0),])[1:5]
top_down <- rownames(resLFC[which(resLFC$log2FoldChange < 0),])[1:5]
EnhancedVolcano(resLFC,
lab = rownames(resLFC),
x = 'log2FoldChange',
y = 'padj',
selectLab = c(top_up,top_down),
xlim = c(-8, 8),
pCutoff = 0.05,
FCcutoff = 1.5,
)
enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05),]),dbs)
#library(tidyverse)
#library(dabestr)
library(enrichR)
enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05),]),dbs)
enriched_combined
# This
enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05 & resLFC$log2FoldChange > 1.5),]),dbs)
enriched_combined
rownames(resLFC[which(resLFC$padj < 0.05 & resLFC$log2FoldChange > 1.5),])
rownames(resLFC[which(resLFC$padj < 0.05),])
# This add log2foldchange threshold.
enriched_combined <- enrichr(rownames(resLFC[which(resLFC$padj < 0.05 & resLFC$log2FoldChange > 1.5),]),dbs)
DT::datatable(head(enriched_combined$GO_Biological_Process_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
DT::datatable(head(enriched_combined$GO_Cellular_Component_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
DT::datatable(head(enriched_combined$GO_Molecular_Function_2018,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
DT::datatable(head(enriched_combined$KEGG_2019_Mouse,n=20)[,c(-3,-5,-6,-7)], extensions = c('FixedColumns','Buttons'),
options = list(
pageLength = 5,
scrollX = TRUE,
scrollCollapse = TRUE,
dom = 'Bfrtip',
buttons = c('copy', 'csv', 'excel')
))
cts <- assay(vsd)
cor.mat <- cor(cts)
my_sample_col <- meta
rownames(my_sample_col) <- meta$Labels
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
my_sample_col
my_sample_col
cts <- assay(vsd)
cor.mat <- cor(cts)
my_sample_col <- meta
rownames(my_sample_col) <- meta$sample
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
cor.mat
my_sample_col
cor.mat
my_sample_col
rownames(my_sample_col) <- meta$sample
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
my_sample_col
my_sample_col <- meta
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
my_sample_col <- meta
my_sample_col
my_sample_col <- meta[, 2:4]
rownames(my_sample_col) <- meta$sample
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
my_sample_col <- meta[, 2:4]
cor.mat <- cor(cts)
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
my_sample_col
rownames(my_sample_col)
rownames(my_sample_col) <- meta$sample
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
rownames(my_sample_col) <- rownames(meta)
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
rownames(my_sample_col)
rownames(meta)
meta
rownames(my_sample_col) <- meta$Name
pheatmap(
mat = cor.mat,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Correlation",
annotation_col = my_sample_col,
show_rownames=FALSE,
show_colnames = FALSE
)
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
my_sample_col <- meta[, 2:4]
rownames(my_sample_col) <- meta$Name
pheatmap(
mat = sampleDistMatrix,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Distance",
annotation_col = my_sample_col,
show_rownames=TRUE,
show_colnames = TRUE
)
rownames(my_sample_col) <- meta$sample
pheatmap(
mat = sampleDistMatrix,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Distance",
annotation_col = my_sample_col,
show_rownames=TRUE,
show_colnames = TRUE
)
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
my_sample_col <- meta[, 2:4]
rownames(my_sample_col) <- meta$sample
pheatmap(
mat = sampleDistMatrix,
cluster_rows = T,
cluster_cols = T,
main = "Sample-Sample Distance",
annotation_col = my_sample_col,
show_rownames=TRUE,
show_colnames = TRUE
)
rownames(my_sample_col) <- meta$Name
my_sample_col
sampleDists
sampleDistMatrix
